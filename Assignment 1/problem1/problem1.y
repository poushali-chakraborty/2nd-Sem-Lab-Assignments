%{
/*
* the definition section of parser
*/
#include <stdio.h>
int yylex(); //the lexer.  
int yyerror();

%}
// definitions of all the tokens we expect to receive from the lexical analyzer.
//In this program, they correspond to the eight parts of speech

%token NOUN PRON VERB ADV ADJ PREP CONJ NOUN_OR_VERB
//begin rule section
%%

sentence: subject VERB object { printf("Sentence is valid.\n"); }
;
subject: NOUN
| PRON | NOUN_OR_VERB 
;
object: NOUN | NOUN_OR_VERB 
;

%%
//end rule section
extern FILE *yyin; //lexer’s input file 
int main()
{
do
{
yyparse();
/*
The main() function of parser repeatedly calls yyparse() until the lexer’s input file runs
out. The routine yyparse() is the parser generated by yacc, so our main program re‐
peatedly tries to parse sentences until the input runs out. (The lexer returns a zero token
whenever it sees a period at the end of a line; that’s the signal to the parser that the input
for the current parse is complete.)
*/
}
while (!feof(yyin));
return 0;
}
/*
What happens if it sees “subject subject” or some other invalid
list of tokens? The parser calls yyerror(), which we provide in the user subroutines
section, and then recognizes the special rule error.
*/
int yyerror(s)
char *s;
{

fprintf(stderr, "1%s\n", s);
}
